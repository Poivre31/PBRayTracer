#version 460 core
#define M_PI 3.14159265358979

// STRUCTS
struct Transform {
	vec3 position;
	vec3 scale;
	vec2 rotation;
};

struct Ray {
	vec3 origin;
	vec3 direction;
};

struct Hit {
	float depth;
	int index;
	int type;
};

uniform struct Count {
	int sphere;
	int cube;
	int plane;
	int circle;
	int cylinder;
	int cone;
	int pyramid;
} count;


// INPUTS
layout(local_size_x = 16,local_size_y = 16,local_size_z = 1) in;
layout(std430, binding = 1) readonly restrict buffer TransfomBuffer
{
	Transform _transforms[];
};

//shared Transform transforms[256];

// FUNCTIONS
vec3 skyColor(vec3 rayDirection);

Ray transformRay(Ray ray, Transform transform);

float intersectSphere(Ray ray, Transform object);
float intersectCube(Ray ray, Transform object);
float intersectPlane(Ray ray, Transform object);
float intersectCircle(Ray ray, Transform object);
float intersectCylinder(Ray ray, Transform object);
float intersectCone(Ray ray, Transform object);
float intersectPyramid(Ray ray, Transform object);


Hit intersect(Ray ray, int startIndex, int nObject, int objectType, Hit hit, int originIndex)
{
//	uint index = gl_LocalInvocationID.x + gl_WorkGroupSize.x * gl_LocalInvocationID.y;
//	if(index < nObject) {
//		transforms[index] = _transforms[index+startIndex];
//	}
//	memoryBarrierShared();
//	barrier();
	for(int i = 0; i < nObject; i++) {
		if(i + startIndex == originIndex) continue;
		Transform object = _transforms[i+startIndex];
		float objectDistance = 0;
		switch(objectType) {
			case 0: {
				objectDistance = intersectSphere(ray, object); break;
			}
			case 1: {
				objectDistance = intersectCube(ray, object); break;
			}
			case 2: {
				objectDistance = intersectPlane(ray, object); break;
			}
			case 3: {
				objectDistance = intersectCircle(ray, object); break;
			}
			case 4: {
				objectDistance = intersectCylinder(ray, object); break;
			}
			case 5: {
				objectDistance = intersectCone(ray, object); break;
			}
			case 6: {
				objectDistance = intersectPyramid(ray, object); break;
			}
		}
		if(objectDistance < hit.depth && objectDistance > 0) {
			hit.depth = objectDistance;
			hit.index = startIndex + i;
			hit.type = objectType;
		}
	}

	return hit;
}

Hit launchRay(Ray ray, int originIndex) {
	Hit hit;
	hit.depth = 1000;
	hit.index = -1;
	hit.type = -1;
	int i = 0;
	hit = intersect(ray, i, count.sphere, 0, hit, originIndex);
	i+=count.sphere;
	hit = intersect(ray, i, count.cube, 1, hit, originIndex);
	i+=count.cube;
	hit = intersect(ray, i, count.plane, 2, hit, originIndex);
	i+=count.plane;
	hit = intersect(ray, i, count.circle, 3, hit, originIndex);
	i+=count.circle;
	hit = intersect(ray, i, count.cylinder, 4, hit, originIndex);
	i+=count.cylinder;
	hit = intersect(ray, i, count.cone, 5, hit, originIndex);
	i+=count.cone;
	hit = intersect(ray, i, count.pyramid, 6, hit, originIndex);

	return hit;
}