#version 460 core
struct Ray {
	vec3 origin;
	vec3 direction;
};

struct Transform {
	vec3 position;
	vec3 scale;
	vec2 rotation;
};

vec3 rotateSpherical(vec3 v, float theta, float phi);
vec3 rotateSphericalInv(vec3 v, float theta, float phi);
Ray transformRay(Ray ray, Transform transform);

float intersectCylinder(Ray ray, Transform object) {
	float dirDotPos = dot(ray.direction, object.position - ray.origin);
	float d2 = dot(object.position - ray.origin, object.position - ray.origin);
	float r2 = max(object.scale.x,object.scale.y);
	r2 = r2*r2 + object.scale.z*object.scale.z;
	if(dirDotPos * dirDotPos <= d2 - r2) return -1.;

	ray = transformRay(ray, object);
	float a = dot(ray.direction.xy, ray.direction.xy);
	float b = dot(ray.origin.xy, ray.direction.xy);
	float c = dot(ray.origin.xy, ray.origin.xy) - 1.;
	
	float delta = b*b-a*c;
	if(delta<0.) return -1.;
	float dist = (-b-sqrt(delta))/a;
	float zIntersect = ray.origin.z + dist * ray.direction.z;
	if(abs(zIntersect) < 1.) return dist;

	dist = -dist - 2. * b / a;
	zIntersect = ray.origin.z + dist * ray.direction.z;
	if(abs(zIntersect) < 1.) return dist;

	return -1;
}

vec3 normalCylinder(Ray ray, float intersectDistance, Transform transform) {
	vec3 intersect =  ray.origin + intersectDistance * ray.direction - transform.position;
	vec3 spherePos = rotateSphericalInv(intersect, transform.rotation.x, transform.rotation.y);
	vec3 normal = vec3(0);
	normal.xy = spherePos.xy / (transform.scale.xy * transform.scale.xy);
	normal = rotateSpherical(normal, transform.rotation.x, transform.rotation.y);

	return normalize(normal);
}