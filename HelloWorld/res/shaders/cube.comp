struct Ray {
	vec3 origin;
	vec3 direction;
};

struct Transform {
	vec3 position;
	vec3 scale;
	vec2 rotation;
};

vec3 rotateSpherical(vec3 v, float theta, float phi);
vec3 rotateSphericalInv(vec3 v, float theta, float phi);
Ray transformRay(Ray ray, Transform transform);

float intersectCube(Ray ray, Transform object) {

	float dirDotPos = dot(ray.direction, object.position - ray.origin);
	float d2 = dot(object.position - ray.origin,object.position - ray.origin);
	float r2 = dot(object.scale,object.scale);
	if(dirDotPos * dirDotPos <= d2 - r2) return -1.;

	ray = transformRay(ray,object);
	vec3 t2 = (sign(ray.direction) - ray.origin) / ray.direction;
	vec3 t1 = (-sign(ray.direction) - ray.origin) / ray.direction;

	float tmin = max(t1.x,max(t1.y,t1.z));
	float tmax = min(t2.x,min(t2.y,t2.z));

	return tmin < tmax ? tmin : -1;
}

vec3 normalCube(Ray ray, float intersectDistance, Transform transform) {
	vec3 intersect =  ray.origin + intersectDistance * ray.direction - transform.position;
	intersect = rotateSphericalInv(intersect, transform.rotation.x, transform.rotation.y) / transform.scale;

	vec3 normal;
	if(abs(intersect.x) > abs(intersect.y) && abs(intersect.x) > abs(intersect.z)) normal = sign(intersect.x) * vec3(1,0,0);
	if(abs(intersect.y) > abs(intersect.x) && abs(intersect.y) > abs(intersect.z)) normal = sign(intersect.y) * vec3(0,1,0);
	if(abs(intersect.z) > abs(intersect.y) && abs(intersect.z) > abs(intersect.x)) normal = sign(intersect.z) * vec3(0,0,1);

	normal = rotateSpherical(normal, transform.rotation.x, transform.rotation.y);
	return normal;
}